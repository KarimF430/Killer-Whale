// Google Maps API utilities for location services

export interface LocationCoordinates {
  lat: number
  lng: number
}

export interface GeocodeResult {
  city: string
  state: string
  country: string
  formattedAddress: string
  coordinates: LocationCoordinates
}

// Initialize Google Maps API via secure server-side proxy
export const loadGoogleMapsAPI = (): Promise<void> => {
  return new Promise((resolve, reject) => {
    if (typeof window === 'undefined') {
      reject(new Error('Window is not defined'))
      return
    }

    // Check if already loaded
    if (window.google && window.google.maps) {
      resolve()
      return
    }

    // Load via server-side proxy to keep API key secure
    const script = document.createElement('script')
    script.src = '/api/google-maps-proxy?action=loadScript'
    script.async = true
    script.defer = true

    script.onload = () => {
      // Wait a bit for Google Maps to fully initialize
      const checkGoogleMaps = setInterval(() => {
        if (window.google && window.google.maps) {
          clearInterval(checkGoogleMaps)
          resolve()
        }
      }, 100)

      // Timeout after 10 seconds
      setTimeout(() => {
        clearInterval(checkGoogleMaps)
        if (window.google && window.google.maps) {
          resolve()
        } else {
          reject(new Error('Google Maps failed to load'))
        }
      }, 10000)
    }
    script.onerror = () => reject(new Error('Failed to load Google Maps API'))

    document.head.appendChild(script)
  })
}

// Reverse geocode coordinates to get city/state
export const reverseGeocode = async (
  lat: number,
  lng: number
): Promise<GeocodeResult | null> => {
  try {
    await loadGoogleMapsAPI()

    return new Promise((resolve, reject) => {
      const geocoder = new google.maps.Geocoder()
      const latlng = { lat, lng }

      geocoder.geocode({ location: latlng }, (results, status) => {
        if (status === 'OK' && results && results[0]) {
          const result = results[0]

          let city = ''
          let state = ''
          let country = ''

          // Extract city and state from address components
          result.address_components.forEach((component) => {
            if (component.types.includes('locality')) {
              city = component.long_name
            }
            if (component.types.includes('administrative_area_level_1')) {
              state = component.long_name
            }
            if (component.types.includes('country')) {
              country = component.long_name
            }
          })

          // Fallback: try sublocality or administrative_area_level_2 for city
          if (!city) {
            result.address_components.forEach((component) => {
              if (component.types.includes('sublocality') ||
                component.types.includes('administrative_area_level_2')) {
                city = component.long_name
              }
            })
          }

          resolve({
            city,
            state,
            country,
            formattedAddress: result.formatted_address,
            coordinates: { lat, lng }
          })
        } else {
          reject(new Error('Geocoding failed: ' + status))
        }
      })
    })
  } catch (error) {
    console.error('Reverse geocoding error:', error)
    return null
  }
}

// Get user's current location using browser geolocation
export const getCurrentLocation = (): Promise<LocationCoordinates> => {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation is not supported by your browser'))
      return
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lng: position.coords.longitude
        })
      },
      (error) => {
        let errorMessage = 'Unable to retrieve your location'

        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'Location permission denied. Please enable location access.'
            break
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'Location information is unavailable.'
            break
          case error.TIMEOUT:
            errorMessage = 'Location request timed out.'
            break
        }

        reject(new Error(errorMessage))
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    )
  })
}

// Autocomplete search for cities using Google Places API
export const searchCitiesWithGoogle = async (
  query: string
): Promise<google.maps.places.AutocompletePrediction[]> => {
  try {
    await loadGoogleMapsAPI()

    return new Promise((resolve, reject) => {
      const service = new google.maps.places.AutocompleteService()

      service.getPlacePredictions(
        {
          input: query,
          types: ['(cities)'],
          componentRestrictions: { country: 'in' } // Restrict to India
        },
        (predictions, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {
            resolve(predictions)
          } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
            resolve([])
          } else {
            reject(new Error('Places search failed: ' + status))
          }
        }
      )
    })
  } catch (error) {
    console.error('City search error:', error)
    return []
  }
}

// Get place details from place_id
export const getPlaceDetails = async (
  placeId: string
): Promise<GeocodeResult | null> => {
  try {
    await loadGoogleMapsAPI()

    return new Promise((resolve, reject) => {
      const service = new google.maps.places.PlacesService(
        document.createElement('div')
      )

      service.getDetails(
        {
          placeId: placeId,
          fields: ['address_components', 'geometry', 'formatted_address']
        },
        (place, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK && place) {
            let city = ''
            let state = ''
            let country = ''

            place.address_components?.forEach((component) => {
              if (component.types.includes('locality')) {
                city = component.long_name
              }
              if (component.types.includes('administrative_area_level_1')) {
                state = component.long_name
              }
              if (component.types.includes('country')) {
                country = component.long_name
              }
            })

            if (!city) {
              place.address_components?.forEach((component) => {
                if (component.types.includes('administrative_area_level_2')) {
                  city = component.long_name
                }
              })
            }

            resolve({
              city,
              state,
              country,
              formattedAddress: place.formatted_address || '',
              coordinates: {
                lat: place.geometry?.location?.lat() || 0,
                lng: place.geometry?.location?.lng() || 0
              }
            })
          } else {
            reject(new Error('Place details failed: ' + status))
          }
        }
      )
    })
  } catch (error) {
    console.error('Place details error:', error)
    return null
  }
}

// Detect location and get city name
export const detectLocationAndGetCity = async (): Promise<GeocodeResult | null> => {
  try {
    const coordinates = await getCurrentLocation()
    const result = await reverseGeocode(coordinates.lat, coordinates.lng)
    return result
  } catch (error) {
    console.error('Location detection error:', error)
    throw error
  }
}
